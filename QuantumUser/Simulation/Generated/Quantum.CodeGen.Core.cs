// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  public enum HorseType : int {
    CarrotLover,
    PaceMaker,
    SpeedRacer,
  }
  public enum RaceState : int {
    None,
    Waiting,
    Countdown,
    InProgress,
    Finishing,
    Finished,
  }
  public enum SurfaceEffect : int {
    None,
    Sand,
    Snow,
    Grass,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    Drift = 1 << 0,
    Powerup = 1 << 1,
    Respawn = 1 << 2,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet6 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 6;
    public Int32 Length {
      get {
        return 6;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet6*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 6, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet6 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet6 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13669;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet6*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Serializable()]
  public unsafe partial struct DriftBoostLevel {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP MinDriftTime;
    [FieldOffset(0)]
    public AssetRef<BoostConfig> BoostAsset;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10639;
        hash = hash * 31 + MinDriftTime.GetHashCode();
        hash = hash * 31 + BoostAsset.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (DriftBoostLevel*)ptr;
        AssetRef.Serialize(&p->BoostAsset, serializer);
        FP.Serialize(&p->MinDriftTime, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(4)]
    public Button Drift;
    [FieldOffset(16)]
    public Button Powerup;
    [FieldOffset(28)]
    public Button Respawn;
    [FieldOffset(0)]
    public Byte Encoded;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + Drift.GetHashCode();
        hash = hash * 31 + Powerup.GetHashCode();
        hash = hash * 31 + Respawn.GetHashCode();
        hash = hash * 31 + Encoded.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 6;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.Drift: return Drift.IsDown;
        case InputButtons.Powerup: return Powerup.IsDown;
        case InputButtons.Respawn: return Respawn.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.Drift: return Drift.WasPressed;
        case InputButtons.Powerup: return Powerup.WasPressed;
        case InputButtons.Respawn: return Respawn.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        serializer.Stream.Serialize(&p->Encoded);
        Button.Serialize(&p->Drift, serializer);
        Button.Serialize(&p->Powerup, serializer);
        Button.Serialize(&p->Respawn, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Serializable()]
  public unsafe partial struct WheelConfig {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FPVector3 Position;
    [FieldOffset(0)]
    public FP Height;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10247;
        hash = hash * 31 + Position.GetHashCode();
        hash = hash * 31 + Height.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (WheelConfig*)ptr;
        FP.Serialize(&p->Height, serializer);
        FPVector3.Serialize(&p->Position, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct WheelStatus {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(40)]
    public FPVector3 HitPoint;
    [FieldOffset(16)]
    public FPVector3 HitNormal;
    [FieldOffset(0)]
    public QBoolean Grounded;
    [FieldOffset(8)]
    public AssetRef<DrivingSurface> HitSurface;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3919;
        hash = hash * 31 + HitPoint.GetHashCode();
        hash = hash * 31 + HitNormal.GetHashCode();
        hash = hash * 31 + Grounded.GetHashCode();
        hash = hash * 31 + HitSurface.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (WheelStatus*)ptr;
        QBoolean.Serialize(&p->Grounded, serializer);
        AssetRef.Serialize(&p->HitSurface, serializer);
        FPVector3.Serialize(&p->HitNormal, serializer);
        FPVector3.Serialize(&p->HitPoint, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 808;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(32)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(48)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(64)]
    public RNGSession RngSession;
    [FieldOffset(80)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(128)]
    public BitSet1024 Systems;
    [FieldOffset(256)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(552)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(556)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 6)]
    private fixed Byte _input_[240];
    [FieldOffset(800)]
    public BitSet6 PlayerLastConnectionState;
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 40, 6); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        return hash;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet6.Serialize(&p->PlayerLastConnectionState, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AIDriver : Quantum.IComponent {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public SByte AIIndex;
    [FieldOffset(48)]
    public FPVector3 TargetLocation;
    [FieldOffset(24)]
    public FPVector3 NextTargetLocation;
    [FieldOffset(8)]
    public AssetRef<AIDriverSettings> SettingsRef;
    [FieldOffset(16)]
    public FP StationaryTime;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3847;
        hash = hash * 31 + AIIndex.GetHashCode();
        hash = hash * 31 + TargetLocation.GetHashCode();
        hash = hash * 31 + NextTargetLocation.GetHashCode();
        hash = hash * 31 + SettingsRef.GetHashCode();
        hash = hash * 31 + StationaryTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AIDriver*)ptr;
        serializer.Stream.Serialize(&p->AIIndex);
        AssetRef.Serialize(&p->SettingsRef, serializer);
        FP.Serialize(&p->StationaryTime, serializer);
        FPVector3.Serialize(&p->NextTargetLocation, serializer);
        FPVector3.Serialize(&p->TargetLocation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Carrot : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public AssetRef<CarrotAsset> Asset;
    [FieldOffset(0)]
    public QBoolean PickedUp;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 9419;
        hash = hash * 31 + Asset.GetHashCode();
        hash = hash * 31 + PickedUp.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Carrot*)ptr;
        QBoolean.Serialize(&p->PickedUp, serializer);
        AssetRef.Serialize(&p->Asset, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Checkpoint : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public SByte Index;
    [FieldOffset(4)]
    public QBoolean Finish;
    [FieldOffset(32)]
    public FPVector3 AIOptimalLocalPosition;
    [FieldOffset(8)]
    public FPVector3 AIBadLocalPosition;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2971;
        hash = hash * 31 + Index.GetHashCode();
        hash = hash * 31 + Finish.GetHashCode();
        hash = hash * 31 + AIOptimalLocalPosition.GetHashCode();
        hash = hash * 31 + AIBadLocalPosition.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Checkpoint*)ptr;
        serializer.Stream.Serialize(&p->Index);
        QBoolean.Serialize(&p->Finish, serializer);
        FPVector3.Serialize(&p->AIBadLocalPosition, serializer);
        FPVector3.Serialize(&p->AIOptimalLocalPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct DriftBoost : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public FP DriftTime;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5569;
        hash = hash * 31 + DriftTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (DriftBoost*)ptr;
        FP.Serialize(&p->DriftTime, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Drifting : Quantum.IComponent {
    public const Int32 SIZE = 80;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int32 Direction;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FP AirTimer;
    [FieldOffset(72)]
    public FP SideAcceleration;
    [FieldOffset(16)]
    public FP ForwardFactor;
    [FieldOffset(48)]
    public FP MaxSteeringOffset;
    [FieldOffset(64)]
    public FP MinimumSpeed;
    [FieldOffset(24)]
    public FP MaxAirTime;
    [FieldOffset(32)]
    public FP MaxNoSteerTime;
    [FieldOffset(56)]
    public FP MinSidewaysSpeedSqr;
    [FieldOffset(40)]
    public FP MaxOppositeSteerTime;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14281;
        hash = hash * 31 + Direction.GetHashCode();
        hash = hash * 31 + AirTimer.GetHashCode();
        hash = hash * 31 + SideAcceleration.GetHashCode();
        hash = hash * 31 + ForwardFactor.GetHashCode();
        hash = hash * 31 + MaxSteeringOffset.GetHashCode();
        hash = hash * 31 + MinimumSpeed.GetHashCode();
        hash = hash * 31 + MaxAirTime.GetHashCode();
        hash = hash * 31 + MaxNoSteerTime.GetHashCode();
        hash = hash * 31 + MinSidewaysSpeedSqr.GetHashCode();
        hash = hash * 31 + MaxOppositeSteerTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Drifting*)ptr;
        serializer.Stream.Serialize(&p->Direction);
        FP.Serialize(&p->AirTimer, serializer);
        FP.Serialize(&p->ForwardFactor, serializer);
        FP.Serialize(&p->MaxAirTime, serializer);
        FP.Serialize(&p->MaxNoSteerTime, serializer);
        FP.Serialize(&p->MaxOppositeSteerTime, serializer);
        FP.Serialize(&p->MaxSteeringOffset, serializer);
        FP.Serialize(&p->MinSidewaysSpeedSqr, serializer);
        FP.Serialize(&p->MinimumSpeed, serializer);
        FP.Serialize(&p->SideAcceleration, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Hazard : Quantum.IComponent {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public EntityRef SpawnedBy;
    [FieldOffset(32)]
    public FP TimeAlive;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public FP TotalTime;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean MarkedForDestruction;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public FPVector3 Movement;
    [FieldOffset(16)]
    public FP DamageRadius;
    [FieldOffset(24)]
    public FP HitDuration;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5591;
        hash = hash * 31 + SpawnedBy.GetHashCode();
        hash = hash * 31 + TimeAlive.GetHashCode();
        hash = hash * 31 + TotalTime.GetHashCode();
        hash = hash * 31 + MarkedForDestruction.GetHashCode();
        hash = hash * 31 + Movement.GetHashCode();
        hash = hash * 31 + DamageRadius.GetHashCode();
        hash = hash * 31 + HitDuration.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Hazard*)ptr;
        QBoolean.Serialize(&p->MarkedForDestruction, serializer);
        EntityRef.Serialize(&p->SpawnedBy, serializer);
        FP.Serialize(&p->DamageRadius, serializer);
        FP.Serialize(&p->HitDuration, serializer);
        FP.Serialize(&p->TimeAlive, serializer);
        FP.Serialize(&p->TotalTime, serializer);
        FPVector3.Serialize(&p->Movement, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Kart : Quantum.IComponent {
    public const Int32 SIZE = 232;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(88)]
    [ExcludeFromPrototype()]
    public ComponentPrototypeRef Prototype;
    [FieldOffset(176)]
    [ExcludeFromPrototype()]
    public FPVector3 Velocity;
    [FieldOffset(152)]
    [ExcludeFromPrototype()]
    public FPVector3 OldVelocity;
    [FieldOffset(128)]
    [ExcludeFromPrototype()]
    public FPVector3 ExternalForce;
    [FieldOffset(104)]
    [ExcludeFromPrototype()]
    public FPVector3 CollisionPositionCompensation;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public FP SidewaysSpeedSqr;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public FP SurfaceFrictionMultiplier;
    [FieldOffset(72)]
    [ExcludeFromPrototype()]
    public FP SurfaceSpeedMultiplier;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public FP SurfaceHandlingMultiplier;
    [FieldOffset(200)]
    [ExcludeFromPrototype()]
    public FPQuaternion TargetRotation;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Byte GroundedWheels;
    [FieldOffset(1)]
    [ExcludeFromPrototype()]
    public Byte OffroadWheels;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public FP AirTime;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FP OffroadTime;
    [FieldOffset(80)]
    [ExcludeFromPrototype()]
    public PhysicsQueryRef OverlapQuery;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public FP Stamina;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public HorseType SelectedHorseType;
    [FieldOffset(8)]
    public AssetRef<KartStats> StatsAsset;
    [FieldOffset(16)]
    public AssetRef<KartVisuals> VisualAsset;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1051;
        hash = hash * 31 + Prototype.GetHashCode();
        hash = hash * 31 + Velocity.GetHashCode();
        hash = hash * 31 + OldVelocity.GetHashCode();
        hash = hash * 31 + ExternalForce.GetHashCode();
        hash = hash * 31 + CollisionPositionCompensation.GetHashCode();
        hash = hash * 31 + SidewaysSpeedSqr.GetHashCode();
        hash = hash * 31 + SurfaceFrictionMultiplier.GetHashCode();
        hash = hash * 31 + SurfaceSpeedMultiplier.GetHashCode();
        hash = hash * 31 + SurfaceHandlingMultiplier.GetHashCode();
        hash = hash * 31 + TargetRotation.GetHashCode();
        hash = hash * 31 + GroundedWheels.GetHashCode();
        hash = hash * 31 + OffroadWheels.GetHashCode();
        hash = hash * 31 + AirTime.GetHashCode();
        hash = hash * 31 + OffroadTime.GetHashCode();
        hash = hash * 31 + OverlapQuery.GetHashCode();
        hash = hash * 31 + Stamina.GetHashCode();
        hash = hash * 31 + (Int32)SelectedHorseType;
        hash = hash * 31 + StatsAsset.GetHashCode();
        hash = hash * 31 + VisualAsset.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Kart*)ptr;
        serializer.Stream.Serialize(&p->GroundedWheels);
        serializer.Stream.Serialize(&p->OffroadWheels);
        serializer.Stream.Serialize((Int32*)&p->SelectedHorseType);
        AssetRef.Serialize(&p->StatsAsset, serializer);
        AssetRef.Serialize(&p->VisualAsset, serializer);
        FP.Serialize(&p->AirTime, serializer);
        FP.Serialize(&p->OffroadTime, serializer);
        FP.Serialize(&p->SidewaysSpeedSqr, serializer);
        FP.Serialize(&p->Stamina, serializer);
        FP.Serialize(&p->SurfaceFrictionMultiplier, serializer);
        FP.Serialize(&p->SurfaceHandlingMultiplier, serializer);
        FP.Serialize(&p->SurfaceSpeedMultiplier, serializer);
        PhysicsQueryRef.Serialize(&p->OverlapQuery, serializer);
        ComponentPrototypeRef.Serialize(&p->Prototype, serializer);
        FPVector3.Serialize(&p->CollisionPositionCompensation, serializer);
        FPVector3.Serialize(&p->ExternalForce, serializer);
        FPVector3.Serialize(&p->OldVelocity, serializer);
        FPVector3.Serialize(&p->Velocity, serializer);
        FPQuaternion.Serialize(&p->TargetRotation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KartBoost : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FP TimeRemaining;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public AssetRef<BoostConfig> CurrentBoost;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4153;
        hash = hash * 31 + TimeRemaining.GetHashCode();
        hash = hash * 31 + CurrentBoost.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KartBoost*)ptr;
        AssetRef.Serialize(&p->CurrentBoost, serializer);
        FP.Serialize(&p->TimeRemaining, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KartHitReceiver : Quantum.IComponent {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public FP HitTimer;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FP ImmunityTimer;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP HitCooldownTimer;
    [FieldOffset(8)]
    public FP HitCooldown;
    [FieldOffset(48)]
    public FPVector3 HitShapeSize;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public PhysicsQueryRef HazardQuery;
    [FieldOffset(0)]
    public LayerMask HazardLayerMask;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14867;
        hash = hash * 31 + HitTimer.GetHashCode();
        hash = hash * 31 + ImmunityTimer.GetHashCode();
        hash = hash * 31 + HitCooldownTimer.GetHashCode();
        hash = hash * 31 + HitCooldown.GetHashCode();
        hash = hash * 31 + HitShapeSize.GetHashCode();
        hash = hash * 31 + HazardQuery.GetHashCode();
        hash = hash * 31 + HazardLayerMask.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KartHitReceiver*)ptr;
        LayerMask.Serialize(&p->HazardLayerMask, serializer);
        FP.Serialize(&p->HitCooldown, serializer);
        FP.Serialize(&p->HitCooldownTimer, serializer);
        FP.Serialize(&p->HitTimer, serializer);
        FP.Serialize(&p->ImmunityTimer, serializer);
        PhysicsQueryRef.Serialize(&p->HazardQuery, serializer);
        FPVector3.Serialize(&p->HitShapeSize, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KartInput : Quantum.IComponent {
    public const Int32 SIZE = 80;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(76)]
    private fixed Byte _alignment_padding_[4];
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public FP Throttle;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public FP Steering;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public Button Drifting;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public FP PreviousSteering;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean PreviousDrifting;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FP SameSteeringTime;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP NoSteeringTime;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FP DriftingInputTime;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public FP SteeringOffset;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20693;
        hash = hash * 31 + Throttle.GetHashCode();
        hash = hash * 31 + Steering.GetHashCode();
        hash = hash * 31 + Drifting.GetHashCode();
        hash = hash * 31 + PreviousSteering.GetHashCode();
        hash = hash * 31 + PreviousDrifting.GetHashCode();
        hash = hash * 31 + SameSteeringTime.GetHashCode();
        hash = hash * 31 + NoSteeringTime.GetHashCode();
        hash = hash * 31 + DriftingInputTime.GetHashCode();
        hash = hash * 31 + SteeringOffset.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KartInput*)ptr;
        QBoolean.Serialize(&p->PreviousDrifting, serializer);
        FP.Serialize(&p->DriftingInputTime, serializer);
        FP.Serialize(&p->NoSteeringTime, serializer);
        FP.Serialize(&p->PreviousSteering, serializer);
        FP.Serialize(&p->SameSteeringTime, serializer);
        FP.Serialize(&p->Steering, serializer);
        FP.Serialize(&p->SteeringOffset, serializer);
        FP.Serialize(&p->Throttle, serializer);
        Button.Serialize(&p->Drifting, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerLink : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public PlayerRef Player;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean Ready;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21391;
        hash = hash * 31 + Player.GetHashCode();
        hash = hash * 31 + Ready.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerLink*)ptr;
        PlayerRef.Serialize(&p->Player, serializer);
        QBoolean.Serialize(&p->Ready, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Race : Quantum.IComponentSingleton {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public RaceState CurrentRaceState;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP CurrentStateTime;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public FrameTimer StateTimer;
    [FieldOffset(1)]
    [ExcludeFromPrototype()]
    public SByte SpawnedAIDrivers;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public Int32 PreviousPlayerCount;
    [FieldOffset(0)]
    public SByte PositionCalcInterval;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16567;
        hash = hash * 31 + (Int32)CurrentRaceState;
        hash = hash * 31 + CurrentStateTime.GetHashCode();
        hash = hash * 31 + StateTimer.GetHashCode();
        hash = hash * 31 + SpawnedAIDrivers.GetHashCode();
        hash = hash * 31 + PreviousPlayerCount.GetHashCode();
        hash = hash * 31 + PositionCalcInterval.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Race*)ptr;
        serializer.Stream.Serialize(&p->PositionCalcInterval);
        serializer.Stream.Serialize(&p->SpawnedAIDrivers);
        serializer.Stream.Serialize(&p->PreviousPlayerCount);
        serializer.Stream.Serialize((Int32*)&p->CurrentRaceState);
        FP.Serialize(&p->CurrentStateTime, serializer);
        FrameTimer.Serialize(&p->StateTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct RaceProgress : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(2)]
    [ExcludeFromPrototype()]
    public SByte TargetCheckpointIndex;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public SByte CurrentLap;
    [FieldOffset(3)]
    [ExcludeFromPrototype()]
    public SByte TotalLaps;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean Finished;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QListPtr<FP> LapTimes;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FP LapTimer;
    [FieldOffset(1)]
    [ExcludeFromPrototype()]
    public SByte Position;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public FP FinishTime;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP DistanceToCheckpoint;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QBoolean LastWrongWay;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19727;
        hash = hash * 31 + TargetCheckpointIndex.GetHashCode();
        hash = hash * 31 + CurrentLap.GetHashCode();
        hash = hash * 31 + TotalLaps.GetHashCode();
        hash = hash * 31 + Finished.GetHashCode();
        hash = hash * 31 + LapTimes.GetHashCode();
        hash = hash * 31 + LapTimer.GetHashCode();
        hash = hash * 31 + Position.GetHashCode();
        hash = hash * 31 + FinishTime.GetHashCode();
        hash = hash * 31 + DistanceToCheckpoint.GetHashCode();
        hash = hash * 31 + LastWrongWay.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      LapTimes = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.RaceProgress*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (RaceProgress*)ptr;
        serializer.Stream.Serialize(&p->CurrentLap);
        serializer.Stream.Serialize(&p->Position);
        serializer.Stream.Serialize(&p->TargetCheckpointIndex);
        serializer.Stream.Serialize(&p->TotalLaps);
        QBoolean.Serialize(&p->Finished, serializer);
        QBoolean.Serialize(&p->LastWrongWay, serializer);
        QList.Serialize(&p->LapTimes, serializer, Statics.SerializeFP);
        FP.Serialize(&p->DistanceToCheckpoint, serializer);
        FP.Serialize(&p->FinishTime, serializer);
        FP.Serialize(&p->LapTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct RaceTrack : Quantum.IComponentSingleton {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(12)]
    public QListPtr<EntityRef> StartPositions;
    [FieldOffset(4)]
    public QListPtr<EntityRef> Checkpoints;
    [FieldOffset(8)]
    public QListPtr<EntityRef> Pickups;
    [FieldOffset(0)]
    public SByte TotalLaps;
    [FieldOffset(16)]
    public AssetRef<NavMesh> NavMesh;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 7159;
        hash = hash * 31 + StartPositions.GetHashCode();
        hash = hash * 31 + Checkpoints.GetHashCode();
        hash = hash * 31 + Pickups.GetHashCode();
        hash = hash * 31 + TotalLaps.GetHashCode();
        hash = hash * 31 + NavMesh.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      StartPositions = default;
      Checkpoints = default;
      Pickups = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.RaceTrack*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (RaceTrack*)ptr;
        serializer.Stream.Serialize(&p->TotalLaps);
        QList.Serialize(&p->Checkpoints, serializer, Statics.SerializeEntityRef);
        QList.Serialize(&p->Pickups, serializer, Statics.SerializeEntityRef);
        QList.Serialize(&p->StartPositions, serializer, Statics.SerializeEntityRef);
        AssetRef.Serialize(&p->NavMesh, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct RespawnMover : Quantum.IComponent {
    public const Int32 SIZE = 128;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public FPVector3 StartPos;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FPVector3 EndPos;
    [FieldOffset(96)]
    [ExcludeFromPrototype()]
    public FPQuaternion StartRot;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public FPQuaternion EndRot;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean Initialized;
    [FieldOffset(8)]
    public FP Progress;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 809;
        hash = hash * 31 + StartPos.GetHashCode();
        hash = hash * 31 + EndPos.GetHashCode();
        hash = hash * 31 + StartRot.GetHashCode();
        hash = hash * 31 + EndRot.GetHashCode();
        hash = hash * 31 + Initialized.GetHashCode();
        hash = hash * 31 + Progress.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (RespawnMover*)ptr;
        QBoolean.Serialize(&p->Initialized, serializer);
        FP.Serialize(&p->Progress, serializer);
        FPVector3.Serialize(&p->EndPos, serializer);
        FPVector3.Serialize(&p->StartPos, serializer);
        FPQuaternion.Serialize(&p->EndRot, serializer);
        FPQuaternion.Serialize(&p->StartRot, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Wheels : Quantum.IComponent {
    public const Int32 SIZE = 480;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(224)]
    [ExcludeFromPrototype()]
    [FramePrinter.FixedArrayAttribute(typeof(WheelStatus), 4)]
    private fixed Byte _WheelStatuses_[256];
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    [FramePrinter.FixedArrayAttribute(typeof(PhysicsQueryRef), 4)]
    private fixed Byte _WheelQueries_[32];
    [FieldOffset(96)]
    [FramePrinter.FixedArrayAttribute(typeof(WheelConfig), 4)]
    private fixed Byte _Configs_[128];
    [FieldOffset(8)]
    public FP GroundedMinimumYFactor;
    [FieldOffset(0)]
    public LayerMask DriveableMask;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public FPVector3 AverageNormal;
    [FieldOffset(72)]
    [ExcludeFromPrototype()]
    public FPVector3 AveragePoint;
    public FixedArray<WheelStatus> WheelStatuses {
      get {
        fixed (byte* p = _WheelStatuses_) { return new FixedArray<WheelStatus>(p, 64, 4); }
      }
    }
    public FixedArray<PhysicsQueryRef> WheelQueries {
      get {
        fixed (byte* p = _WheelQueries_) { return new FixedArray<PhysicsQueryRef>(p, 8, 4); }
      }
    }
    public FixedArray<WheelConfig> Configs {
      get {
        fixed (byte* p = _Configs_) { return new FixedArray<WheelConfig>(p, 32, 4); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 11171;
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(WheelStatuses);
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(WheelQueries);
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(Configs);
        hash = hash * 31 + GroundedMinimumYFactor.GetHashCode();
        hash = hash * 31 + DriveableMask.GetHashCode();
        hash = hash * 31 + AverageNormal.GetHashCode();
        hash = hash * 31 + AveragePoint.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Wheels*)ptr;
        LayerMask.Serialize(&p->DriveableMask, serializer);
        FP.Serialize(&p->GroundedMinimumYFactor, serializer);
        FixedArray.Serialize(p->WheelQueries, serializer, Statics.SerializePhysicsQueryRef);
        FPVector3.Serialize(&p->AverageNormal, serializer);
        FPVector3.Serialize(&p->AveragePoint, serializer);
        FixedArray.Serialize(p->Configs, serializer, Statics.SerializeWheelConfig);
        FixedArray.Serialize(p->WheelStatuses, serializer, Statics.SerializeWheelStatus);
    }
  }
  public unsafe partial interface ISignalRaceStateChanged : ISignal {
    void RaceStateChanged(Frame f, RaceState state);
  }
  public unsafe partial interface ISignalPlayerFinished : ISignal {
    void PlayerFinished(Frame f, EntityRef entity);
  }
  public static unsafe partial class Constants {
  }
  public unsafe partial class Frame {
    private ISignalRaceStateChanged[] _ISignalRaceStateChangedSystems;
    private ISignalPlayerFinished[] _ISignalPlayerFinishedSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalRaceStateChangedSystems = BuildSignalsArray<ISignalRaceStateChanged>();
      _ISignalPlayerFinishedSystems = BuildSignalsArray<ISignalPlayerFinished>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<Quantum.AIDriver>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AIDriver>();
      BuildSignalsArrayOnComponentAdded<Quantum.Carrot>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Carrot>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.Checkpoint>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Checkpoint>();
      BuildSignalsArrayOnComponentAdded<Quantum.DriftBoost>();
      BuildSignalsArrayOnComponentRemoved<Quantum.DriftBoost>();
      BuildSignalsArrayOnComponentAdded<Quantum.Drifting>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Drifting>();
      BuildSignalsArrayOnComponentAdded<Quantum.Hazard>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Hazard>();
      BuildSignalsArrayOnComponentAdded<Quantum.Kart>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Kart>();
      BuildSignalsArrayOnComponentAdded<Quantum.KartBoost>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KartBoost>();
      BuildSignalsArrayOnComponentAdded<Quantum.KartHitReceiver>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KartHitReceiver>();
      BuildSignalsArrayOnComponentAdded<Quantum.KartInput>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KartInput>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.Race>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Race>();
      BuildSignalsArrayOnComponentAdded<Quantum.RaceProgress>();
      BuildSignalsArrayOnComponentRemoved<Quantum.RaceProgress>();
      BuildSignalsArrayOnComponentAdded<Quantum.RaceTrack>();
      BuildSignalsArrayOnComponentRemoved<Quantum.RaceTrack>();
      BuildSignalsArrayOnComponentAdded<Quantum.RespawnMover>();
      BuildSignalsArrayOnComponentRemoved<Quantum.RespawnMover>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
      BuildSignalsArrayOnComponentAdded<Quantum.Wheels>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Wheels>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->Drift = i->Drift.Update(this.Number, input.Drift);
      i->Powerup = i->Powerup.Update(this.Number, input.Powerup);
      i->Respawn = i->Respawn.Update(this.Number, input.Respawn);
      i->Encoded = input.Encoded;
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      if (Context.Physics2D != null && Physics2D.Map != null && Physics2D.Map.Guid.IsDynamic) Physics2D.ResetMap();
      Physics2D.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      if (Context.Physics3D != null && Physics3D.Map != null && Physics3D.Map.Guid.IsDynamic) Physics3D.ResetMap();
      Physics3D.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void RaceStateChanged(RaceState state) {
        var array = _f._ISignalRaceStateChangedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.RaceStateChanged(_f, state);
          }
        }
      }
      public void PlayerFinished(EntityRef entity) {
        var array = _f._ISignalPlayerFinishedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.PlayerFinished(_f, entity);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializeFP;
    public static FrameSerializer.Delegate SerializeEntityRef;
    public static FrameSerializer.Delegate SerializeWheelConfig;
    public static FrameSerializer.Delegate SerializePhysicsQueryRef;
    public static FrameSerializer.Delegate SerializeWheelStatus;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializeFP = FP.Serialize;
      SerializeEntityRef = EntityRef.Serialize;
      SerializeWheelConfig = Quantum.WheelConfig.Serialize;
      SerializePhysicsQueryRef = PhysicsQueryRef.Serialize;
      SerializeWheelStatus = Quantum.WheelStatus.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(Quantum.AIDriver), Quantum.AIDriver.SIZE);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet6), Quantum.BitSet6.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CallbackFlags), 4);
      typeRegistry.Register(typeof(Quantum.Carrot), Quantum.Carrot.SIZE);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Checkpoint), Quantum.Checkpoint.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.DriftBoost), Quantum.DriftBoost.SIZE);
      typeRegistry.Register(typeof(Quantum.DriftBoostLevel), Quantum.DriftBoostLevel.SIZE);
      typeRegistry.Register(typeof(Quantum.Drifting), Quantum.Drifting.SIZE);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.Hazard), Quantum.Hazard.SIZE);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.HorseType), 4);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(IntVector2), IntVector2.SIZE);
      typeRegistry.Register(typeof(IntVector3), IntVector3.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Kart), Quantum.Kart.SIZE);
      typeRegistry.Register(typeof(Quantum.KartBoost), Quantum.KartBoost.SIZE);
      typeRegistry.Register(typeof(Quantum.KartHitReceiver), Quantum.KartHitReceiver.SIZE);
      typeRegistry.Register(typeof(Quantum.KartInput), Quantum.KartInput.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerLink), Quantum.PlayerLink.SIZE);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(QueryOptions), 2);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Quantum.Race), Quantum.Race.SIZE);
      typeRegistry.Register(typeof(Quantum.RaceProgress), Quantum.RaceProgress.SIZE);
      typeRegistry.Register(typeof(Quantum.RaceState), 4);
      typeRegistry.Register(typeof(Quantum.RaceTrack), Quantum.RaceTrack.SIZE);
      typeRegistry.Register(typeof(Quantum.RespawnMover), Quantum.RespawnMover.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.SurfaceEffect), 4);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum.WheelConfig), Quantum.WheelConfig.SIZE);
      typeRegistry.Register(typeof(Quantum.WheelStatus), Quantum.WheelStatus.SIZE);
      typeRegistry.Register(typeof(Quantum.Wheels), Quantum.Wheels.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 16)
        .AddBuiltInComponents()
        .Add<Quantum.AIDriver>(Quantum.AIDriver.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Carrot>(Quantum.Carrot.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Checkpoint>(Quantum.Checkpoint.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.DriftBoost>(Quantum.DriftBoost.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Drifting>(Quantum.Drifting.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Hazard>(Quantum.Hazard.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Kart>(Quantum.Kart.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.KartBoost>(Quantum.KartBoost.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.KartHitReceiver>(Quantum.KartHitReceiver.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.KartInput>(Quantum.KartInput.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerLink>(Quantum.PlayerLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Race>(Quantum.Race.Serialize, null, null, ComponentFlags.Singleton)
        .Add<Quantum.RaceProgress>(Quantum.RaceProgress.Serialize, null, Quantum.RaceProgress.OnRemoved, ComponentFlags.None)
        .Add<Quantum.RaceTrack>(Quantum.RaceTrack.Serialize, null, Quantum.RaceTrack.OnRemoved, ComponentFlags.Singleton)
        .Add<Quantum.RespawnMover>(Quantum.RespawnMover.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Wheels>(Quantum.Wheels.Serialize, null, null, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<CallbackFlags>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.HorseType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<QueryOptions>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.RaceState>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.SurfaceEffect>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
